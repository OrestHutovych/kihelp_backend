package org.example.kihelp_back.task.usecase.impl;

import org.example.kihelp_back.discount.service.DiscountService;
import org.example.kihelp_back.global.api.idencoder.IdEncoderApiRepository;
import org.example.kihelp_back.history.model.History;
import org.example.kihelp_back.history.model.HistoryStatus;
import org.example.kihelp_back.history.service.HistoryService;
import org.example.kihelp_back.invite.service.InviteService;
import org.example.kihelp_back.task.dto.TaskGenerateDto;
import org.example.kihelp_back.task.dto.TaskProcessCreateDto;
import org.example.kihelp_back.task.model.Task;
import org.example.kihelp_back.task.service.TaskService;
import org.example.kihelp_back.task.usecase.TaskProcessUseCase;
import org.example.kihelp_back.user.exception.UserIsBannedException;
import org.example.kihelp_back.user.model.User;
import org.example.kihelp_back.user.service.UserService;
import org.example.kihelp_back.wallet.service.WalletService;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.MathContext;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

import static org.example.kihelp_back.task.util.TaskErrorMessage.USER_BANNED_BY_RESELLER_ACTIVITY;
import static org.example.kihelp_back.user.util.UserErrorMessage.USER_IS_BANNED;

@Component
public class TaskProcessUseCaseFacade implements TaskProcessUseCase {
    private final TaskService taskService;
    private final HistoryService historyService;
    private final UserService userService;
    private final WalletService walletService;
    private final InviteService inviteService;
    private final DiscountService discountService;
    private final IdEncoderApiRepository idEncoderApiRepository;

    public TaskProcessUseCaseFacade(TaskService taskService,
                                    HistoryService historyService,
                                    UserService userService,
                                    WalletService walletService,
                                    InviteService inviteService,
                                    DiscountService discountService,
                                    IdEncoderApiRepository idEncoderApiRepository) {
        this.taskService = taskService;
        this.historyService = historyService;
        this.userService = userService;
        this.walletService = walletService;
        this.inviteService = inviteService;
        this.discountService = discountService;
        this.idEncoderApiRepository = idEncoderApiRepository;
    }

    @Override
    @Transactional
    public Map<String, String> processTask(TaskProcessCreateDto request) {
        User targetUser = userService.findByJwt();
        Long decodeTaskId = idEncoderApiRepository.findEncoderByName("task").decode(request.taskId()).get(0);
        Task task = taskService.getTaskById(decodeTaskId);

        validateUserStatus(targetUser, decodeTaskId);

        if (!hasRole(targetUser, "ROLE_ADMIN") && !isTaskDeveloper(targetUser, task)) {
            BigDecimal discount = discountService.updateDiscount(task.getId(), targetUser.getId());
            BigDecimal price = calculateDiscountPrice(task.getPrice(), discount);

            walletService.withdrawAmountFromWalletByUserId(targetUser.getId(), price, true);
            walletService.depositAmountToWalletByUserId(task.getDeveloper().getId(), price, false);
            inviteService.depositToInviteeSpendBalance(targetUser.getId(), price);
        }

        Map<String, String> processResponse = new HashMap<>();
        processResponse.put("taskTitle", task.getTitle());
        processResponse.put("subjectName", task.getTeacher().getSubject().getName());
        processResponse.put("developerName", task.getDeveloper().getUsername());

        if(task.isAutoGenerate()){
            processAutoGeneratedTask(targetUser, task, request, processResponse);
        }else{
            processManualTask(targetUser, task, request, processResponse);
        }

        return processResponse;
    }

    private void validateUserStatus(User targetUser, Long taskId){
        if (targetUser.isBanned()) {
            throw new UserIsBannedException(String.format(USER_IS_BANNED, targetUser.getTelegramId()));
        }

        boolean isDetected = historyService.detectResellerActivity(targetUser.getTelegramId(), taskId);

        if(isDetected) {
            userService.changeBan(targetUser.getTelegramId(), true);
            throw new UserIsBannedException(String.format(USER_BANNED_BY_RESELLER_ACTIVITY, targetUser.getTelegramId()));
        }
    }

    private boolean hasRole(User user, String roleName) {
        return user.getRoles().stream().anyMatch(role -> roleName.equals(role.getName()));
    }

    private boolean isTaskDeveloper(User targetUser, Task task) {
        return hasRole(targetUser, "ROLE_DEVELOPER") &&
                task.getDeveloper().getTelegramId().equals(targetUser.getTelegramId());
    }

    private BigDecimal calculateDiscountPrice(BigDecimal price, BigDecimal discount) {
        if(discount.compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal discountRate = discount.divide(BigDecimal.valueOf(100.0), MathContext.DECIMAL64);
            return price.subtract(price.multiply(discountRate));
        }

        return price;
    }

    private void processAutoGeneratedTask(User targetUser, Task task, TaskProcessCreateDto request, Map<String, String> processResponse) {
        TaskGenerateDto taskProcessResponse = taskService.process(targetUser, task, request);

        History historyToSave = History.builder()
                .name(taskProcessResponse.fileName())
                .link(taskProcessResponse.link())
                .arguments(request.arguments().toString())
                .status(HistoryStatus.COMPLETED)
                .createdAt(taskProcessResponse.createdAt())
                .user(targetUser)
                .task(task)
                .build();
        historyService.save(historyToSave);

        processResponse.put("fileName", taskProcessResponse.fileName());
        processResponse.put("link", taskProcessResponse.link());
        processResponse.put("createdAt", taskProcessResponse.createdAt().toString());
    }

    private void processManualTask(User targetUser, Task task, TaskProcessCreateDto request, Map<String, String> processResponse) {
        Instant now = Instant.now();
        History historyToSave = History.builder()
                .arguments(request.arguments().toString())
                .status(HistoryStatus.IN_PROGRESS)
                .createdAt(now)
                .user(targetUser)
                .task(task)
                .build();
        historyService.save(historyToSave);

        processResponse.put("message", "Протягом 1 години розробник відпише вам, " +
                "щоб уточнити деталі для подальшої розробки" +
                "завдання відносно вашого запиту.");
        processResponse.put("createdAt", now.toString());
    }
}
